import sys
import argparse
import os
#import httplib
import subprocess
import ftplib
#import urllib2
import socket
import urllib
import sys
import json
import telnetlib
import glob
import random
#import Queue
import threading
import base64
import time
#import ConfigParser
from sys import argv
from commands import *
from getpass import getpass
from xml.dom import minidom
#from urlparse import urlparse
from optparse import OptionParser
from time import gmtime, strftime, sleep
import dns.resolver
import re
import pyfiglet
import urllib.request, urllib.error, urllib.parse
from html.parser import HTMLParser
#import scapy.all as scapy
#from scapy.all import *
import time
import threading
import scapy
from queue import Queue
import os
import requests, os, nmap, ipwhois, socket
from scapy.layers.inet import IP, ICMP, sr1,TCP,sr
from scapy.volatile import RandShort
installDir = os.path.dirname(os.path.abspath(__file__)) + '/'
class color:
    HEADER = '\033[95m'
    IMPORTANT = '\33[35m'
    NOTICE = '\033[33m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    UNDERLINE = '\033[4m'
    LOGGING = '\33[34m'

# --------------------Website-----------------
def request(url):
    try:
        return requests.get("http://" + url)

    except requests.exceptions.ConnectionError:
        pass
def pathfinder(url,arr):
    response = requests.get(url)
    #print(response.links)
    try:
        link = re.findall('(?:href=")(.*?)"', response.content.decode('utf-8'))
        for i in link:
            i = urllib.parse.urljoin(url,i)
            if url in i and i not in arr:
                arr.append(i)

                print(i)
                pathfinder(i,arr)
    except:
        pass
def header(target):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    t_host = target
    t_port = 80
    try:
        sock.connect((t_host, t_port))
        p = 'GET HTTP/1.1 \r \n'
        sock.send(p.encode('utf-8'))

        ret = sock.recv(1024)
        ret = str(ret)
        ret = ret.split("\\r\\n")
        for i in ret:
            # i = i.split("\\n")
            print(i)
    except:
        print("Unable to connect")
def tracert(target,hop):
    res, unans = sr(IP(dst=target, ttl=(1, hop)) / TCP(sport=RandShort()))
    res.make_table(lambda s, r: (s.dst, s.ttl, r.sprintf("%IP.src% \t {TCP:%TCP.flags%}")))
#---------------- Os dection -------------
def osd(target):
    pack = IP(dst=target)/ICMP()
    resp = sr1(pack,timeout=2)
    if resp == None:
        print("No Response:- Can not find server information")
    elif IP in resp:
        if resp.getlayer(IP).ttl <= 64:
            os = "Linux"
            hop = 64 - resp.getlayer(IP).ttl
            print("Network distance - " + str(hop))
            print("Trace route : --")
            tracert(target,hop)
        else:
            os = "Windows"
            hop = 128 - resp.getlayer(IP).ttl
            print("Network distance - " + str(hop))
            print("Trace route : --")
            tracert(target, hop)
        print("Server OS :- "+ os)

def ftpvu(hostname):
    try:
        ftp = ftplib.FTP(hostname)
        ftp.login('anonymous', 'anonymous')
        print(ftp.getwelcome())
        ftp.set_pasv(1)
        print(ftp.dir())
        print('\n[*] ' + str(hostname) + ' FTP Anonymous Login Succeeded.')
        return ftp
    except Exception as e:
        print(str(e))
        print('\n[-] ' + str(hostname) + ' FTP Anonymous Login Failed.')
        return

def scan(ip):
    # scapy.arping(ip)
    arp_request = scapy.ARP(pdst=ip)
    broadcast = scapy.Ether(dst='ff:ff:ff:ff:ff:ff')
    arp_request_broadcast = broadcast / arp_request
    answered_list = scapy.srp(arp_request_broadcast, timeout=5, verbose=False)[0]

    arr = []
    for i in answered_list:
        # print(i[1].psrc+"\t\t\t"+i[1].hwsrc)
        dict = {"ip": i[1].psrc, "mac": i[1].hwsrc}
        arr.append(dict)
    return arr

    # print(i[1].hwsrc)
    # print("---------------------------")
def printfun(re):
    print("    IP \t\t\t\t MAC Address")
    print("-------------------------------------------------")
    for i in re:
        print(i["ip"]+"\t\t\t"+i["mac"])

def port(target,portarr):
    socket.setdefaulttimeout(0.25)
    print_lock = threading.Lock()

    #target = input('Enter the host to be scanned: ')

    t_IP = socket.gethostbyname(target)
    print('Starting scan on host: ', t_IP)
    k = socket.gethostbyaddr(target)
    print('Running services on ', k[0])
    osd(target)

    def portscan(port):
        protocolname = 'tcp'
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            con = s.connect((t_IP, port))
            with print_lock:
                print(port, 'is open')
                portarr.append(port)
                print("Port: %s => service name: %s" % (port, socket.getservbyport(port, protocolname)))
            con.close()
        except:
            pass

    def threader():
        while True:
            worker = q.get()
            portscan(worker)
            q.task_done()

    q = Queue()
    startTime = time.time()

    for x in range(100):
        t = threading.Thread(target=threader)
        t.daemon = True
        t.start()

    for worker in range(1, 20000):
        q.put(worker)

    q.join()
    print('Time taken:', time.time() - startTime)



def admin(url):
    start = "Start Scaning...\n"
    for s in start:
        sys.stdout.write(s)
        sys.stdout.flush()
        sleep(0.1)
    file = open("admin_panels.txt", "r")  # Open files containing possible admin directories
    try:
        for link in file.read().splitlines():
            curl = url + link
            res = requests.get(curl)
            if res.status_code == 200:
                print("*" * 15)
                print("Admin panel found ==> {}".format(curl))
                print("*" * 15)
            else:
                pass
                #print("\033[91m Not found ==> {} \033[0m".format(curl))
    except KeyboardInterrupt:
        print("\033[91m Shutdown Request! \033[0m")
    except:
        print("\033[91m Unknown Error! \033[0m")
    file.close()
def fun(n, temp):
    portarr = []
    if n == 1:
        target = input('Enter the host to be scanned: ')
        print("1:- single port scan")
        print("2:- Range of port scan")
        temp = int(input('Enter the choice: '))

        if temp == 1:
            portt = int(input("Enter the port no"))
            lport = portt
            rport = portt
            port(target)
        elif temp == 2:
            #lport = int(input('Enter the first port range: '))
            #rport = int(input('Enter the second port range: '))
            port(target)
        else:
            print("Incorrect Input")


    elif n == 2:

        print("1:- Subdomains")

        print("2:- URL Paths")
        print("3:- Whois")

        print("4:- All ")

        print("5:- Back")

        k = int(input("Enter Your choice  "))

        if k == 1:

            url = input('Enter the url ex(google.com)(Do not use prefix):- ')


            with open("subdomains-wodlist.txt", "r") as list:

                for line in list:

                    word = line.strip()

                    final = word + "." + url
                    try:

                        response = request(final)
                    except:
                        pass
                    if response:
                        print("[+] Discovered subdmain --> " + final)

        elif k == 2:

            arr = []

            url = input('Enter the url ex(www.iiitm.ac.in/)(write whole web address):- ')

            # url = request(url)

            url = "http://" + url

            pathfinder(url, arr)
        elif k == 3:
            ip = input('\033[36mEnter target ip: \033[0m')
            resault = ipwhois.IPWhois(ip).lookup_whois()
            print(resault)
            main()
        elif k == 4:

            url1 = input('Enter the url ex(google.com)(Do not use prefix):- ')
            url = 'http://' + url1

            ans = dns.resolver.resolve(url1, 'NS')
            A = dns.resolver.resolve(url1, 'A')
            MX = dns.resolver.resolve(url1, 'MX')
            for server in ans:
                print("[+] NS server-->"+str(server))
            for server in A:
                print("[+] A server-->"+str(server))
            for server in MX:
                print("[+] MX server-->"+str(server))
            arr = []
            ip_address = socket.gethostbyname(url1)
            resault = ipwhois.IPWhois(ip_address).lookup_whois()
            print(resault)
            for i in resault:
                print(i)
            port(url1,portarr)
            for i in portarr:
                print("Open port are -- " + str(i))
                if i == 21:
                    ftpvu(ip_address)
            #------------------------------get header ----------------------------------------
            header(url1)
            # ----------------------------------------------------------------------------
            # Wordpress Scan
            print("")
            print("--------------Wordpress Scan--------------")
            print("Scan for Wordpress...")
            sleep(2)
            wpLcheck = requests.get(url + "/wp-login.php")
            if wpLcheck.status_code == 200 and "user_login" in wpLcheck.text and "404" not in wpLcheck.text:
                print("Wordpress detected: admin login => " + url + "/wp-admin.php")
            else:
                pass

            wpAcheck = requests.get(url + "/wp-admin")
            if wpAcheck.status_code == 200 and "user_login" in wpAcheck.text and "404" not in wpAcheck.text:
                print("Wordpress detected: admin page => " + url + "/wp-admin")
            else:
                pass

            # Joomla Scan
            print("")
            print("--------------joomla Scan--------------")
            print("Scan for Joomla...")
            sleep(2)
            jmAcheck = requests.get(url + "/administrator")
            if jmAcheck.status_code == 200 and "mod-login-username" in jmAcheck.text and "404" not in jmAcheck.text:
                print("Joomla detected: administrator page => " + url + "/administrator")
            else:
                pass

            jmScheck = requests.get(url)
            if jmScheck.status_code == 200 and "joomla" in jmScheck.text and "404" not in jmScheck:
                print("Joomla detected: 'joomla' on index")
            else:
                pass

            # Drupal Scan
            print("")
            print("--------------Drupal Scan--------------")
            print("Scan for Drupal...")
            sleep(2)
            drRcheck = requests.get(url + "/readme.txt")
            if drRcheck.status_code == 200 and 'drupal' in drRcheck.text and '404' not in drRcheck.text:
                print("Drupal detected: Drupal Readme.txt => " + url + '/readme.txt')
            else:
                pass

            drCcheck = requests.get(url + '/core/COPYRIGHT.txt')
            if drCcheck.status_code == 200 and 'Drupal' in drCcheck.text and '404' not in drCcheck.text:
                print("Drupal detected: Drupal COPYRIGHT.txt => " + url + '/core/COPYRIGHT.txt')
            else:
                pass

            # Magento Scan -----------------------------------------
            print("")
            print("--------------Magento Scan--------------")
            print("Scan for Magento...")
            sleep(2)
            mgRcheck = requests.get(url + '/RELEASE_NOTES.txt')
            if mgRcheck.status_code == 200 and 'magento' in mgRcheck.text:
                print("Magento detected: Magento Release_Notes.txt: " + url + '/RELEASE_NOTES.txt')
            else:
                pass

            mgCcheck = requests.get(url + '/js/mage/cookies.js')
            if mgCcheck.status_code == 200 and "404" not in mgCcheck.text:
                print("Magento detected: Magento cookies.js: " + url + '/js/mage/cookies.js')
            else:
                pass
            ##-----------------
            print("Scanning for path")
            pathfinder(url, arr)
        #---------------------------------------------------------------------------------------------
            admin(url)
            #-----------------------------------------------------------------------------------------------
            with open("subdomains-wodlist.txt", "r") as list:
                for line in list:
                    word = line.strip()
                    final = word + "." + url1
                    try:
                        response = request(final)
                    except:
                        pass
                    if response:
                        print("[+] Discovered subdmain --> " + final)


def main():
    print("-----------------Welcome to VSTK----------------------")
    print("1:- Scan Local Server")
    print("2:- Scan Websites")
    print("3:- Port Scan")
    print("4:- Network Scan")
    print("5:- For kali linux")
    print("5:- Exit")
    n = int(input('Enter your choice:- '))
    temp = []
    fun(n,temp)


if __name__ == '__main__':
    ascii_banner = pyfiglet.figlet_format("VSTK SCANNER")
    color_random = [color.HEADER, color.IMPORTANT, color.NOTICE, color.OKBLUE, color.OKGREEN, color.WARNING, color.RED,
                    color.END, color.UNDERLINE, color.LOGGING]
    logo = random.choice(color_random) + ascii_banner
    print(logo)
    #nmap()
    main()
